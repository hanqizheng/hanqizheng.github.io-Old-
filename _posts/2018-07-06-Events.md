---
layout:     post
title:      "Events"
subtitle:   "事件驱动，带你走进Node.js的世界"
date:       2018-07-06
author:     "Han Qizheng"
header-img: "img/home-bg-o.jpg"
tags:
    - Node.js
---

# Events

2018-07-06

请先允许我给自己复习几个概念（明明操作系统刚学了！！掀桌.jpg）

## 并发和并行

**并行**，是真的同时在做很多事情。

**并发**，其实操作系统学过一个叫做时间片轮转的算法，就是给每个进(线)程一定时间的CPU（处理机、核）使用权，各个进程之间轮流使用CPU。其实如果我们可以走到线程的微观角度，就能发现这些任务并非同时在执行，他们是交替轮流执行的。但是由于CPU处理速度很快，时间片的长度又很短，所以在我们宏观的角度上看来这些任务就像是在同时执行一样。

解释的不准确，但可以这么理解。

## 阻塞和非阻塞

还是操作系统刚学过的（我却还不熟悉，跪地.jpg）

进程有三个基本状态，就绪，执行，阻塞。

阻塞的最常见的触发条件就是有I/O请求来了，进程就要等待I/O，知道I/O执行完毕，才会继续往下执行。这里等待，就是进程阻塞等待。

node.js是单进程单线程的，但这不代表他只能顺序执行遇到I/O就阻塞等待，这样显然是不高效的，缓慢的。

所以今天学习了node.js的事件驱动程序

## 事件驱动
事件驱动要理解起来，我要引用Dan York举的两个很经典的例子。

**看病**
    
在美国去看医生，需要填写大量表格，比如保险、个人信息之类，传统的基于线程的系统（thread-based system），接待员叫到你，你需要在前台填写完成这些表格，你站着填单，而接待员坐着看你填单。你让接待员没办法接待下一个客户，除非完成你的业务。

想让这个系统能运行的快一些，只有多加几个接待员，人力成本需要增加不少。

基于事件的系统（event-based system）中，当你到窗口发现需要填写一些额外的表格而不仅仅是挂个号，接待员把表格和笔给你，告诉你可以找个座位填写，填完了以后再回去找他。你回去坐着填表，而接待员开始接待下一个客户。你没有阻塞接待员的服务。
 
你填完表格，返回队伍中，等接待员接待完现在的客户，你把表格递给他。如果有什么问题或者需要填写额外的表格，他给你一份新的，然后重复这个过程。

这个系统已经非常高效了，几乎大部分医生都是这么做的。如果等待的人太多，可以加入额外的接待员进行服务，但是肯定要比基于线程模式的少得多




**快餐店点餐**


在基于线程的方式中（thread-based way）你到了柜台前，把你的点餐单给收银员或者给收银员直接点餐，然后等在那直到你要的食物准备好给你。收银员不能接待下一个人，除非你拿到食物离开。想接待更多的客户，容易！加更多的收银员！


当然，我们知道快餐店其实不是这样工作的。他们其实就是基于事件驱动方式，这样收银员更高效。只要你把点餐单给收银员，某个人已经开始准备你的食物，而同时收银员在进行收款，当你付完钱，你就站在一边而收银员已经开始接待下一个客户。在一些餐馆，甚至会给你一个号码，如果你的食物准备好了，就呼叫你的号码让你去柜台取。关键的一点是，你没有阻塞下一个客户的订餐请求。你订餐的食物做好的事件会导致某个人做某个动作（某个服务员喊你的订单号码，你听到你的号码被喊到去取食物），在编程领域，我们称这个为回调（callback function）。
    
如果耐心看完了这两个例子，我相信绝对和我刚看完的时候一样，恍然大悟。其实Node.js的事件驱动大概就是这个样子，他不会阻塞等待I/O请求或者一系列会让当前任务进入阻塞状态的事件。

而是当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）


```js
//代码在demo文件夹里

// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();

// 创建事件处理程序
var connectHandler = function connected() {
   console.log('连接成功。');
  
   // 触发 data_received 事件 
   eventEmitter.emit('data_received');
}

// 绑定 connection 事件处理程序
eventEmitter.on('connection', connectHandler);
 
// 使用匿名函数绑定 data_received 事件
eventEmitter.on('data_received', function(){
   console.log('数据接收成功。');
});

// 触发 connection 事件 
eventEmitter.emit('connection');

console.log("程序执行完毕。");

//连接成功。
//数据接收成功。
//程序执行完毕。
```

看上面的代码，顺序就是先将一个函数与'connection'事件绑定，然后同样的给'data_received'事件绑定一个函数。绑定用eventemitter.on()来完成。

然后就是激活这个事件，使用eventemitter.emit()来触发。当触发一个事件，比如'connection‘，就会调用与之绑定的函数。

